%% Noise Model
%  Illustration of different noise types in digital images.
%% Experiment Description:
% This experiment illustrates the different noises effect digital image
% capturing, and the noise effect on the 1D power spectrum and auto
% correlation function of the image.
%
% a method of detecting the noise from the power spectrum is also
% introduced, and its sensitivity is controllable.
% 
% The noises introduced are:
%
% * Additive Gaussian Noise
% * Periodic Noise
% * Row - Column Noise
% * Shot Noise
% * Impulse Noise
%% Tasks: 
% 6.1.1. Additive noise model.
%
% Generate and observe additive Gaussian noise in images. Compare 1-D power spectra
% of noisy and noise less images. Observe image auto-correlation functions (program
% corimg1d.m). Evaluate noise variance (program noisevar.m) and investigate its accuracy for
% different SNR.
% Generate periodic noise image, use program detmoir1.m to characterize it. Images
% moire.img, jeep.img, magcrop.img can be used along with those generated by you.
%
% 6.1.2. Impulse noise model.
%
% Generate and observe impulse noise in images. Observe difference signal histograms
% of noisy and noise less images (program pnoise.m). Investigate, how noise variance
% estimation found by program noisevar.m is connected to the probability of errors.
%
%% Instruction:
% use the 'Choose Noise Type' panel to switch between the different noise
% models presented.
%
% Each of the noise mode has distinct parameters which effect behavior of
% the noise.
%
% For all noises models the noise detection parameter can be controlled by
% the 'Set Threshold For Noise Detection' slider.
%
% *Additive Gaussian Noise -*
% 
% * 'Set Gaussian STD' sliders control the mean and
% variance of the Gaussian noise added to the image.
%
% *Periodic Noise-*
%
% * 'Set Omega X',  'Set Theta X' sliders control the frequency and phase of
% the Additive Periodic Noise along the X axis.
%
% * 'Set Omega Y',  'Set Theta Y' sliders control the frequency and phase of
% the Additive Periodic Noise along the Y axis.
% 
% * 'Set Noise Variance' slider controls the overall noise variance (along X
% and Y axis). 
%
% *Row - Column Noise-* 
% 
% * 'Set Column Noise Variance' slider control the noise variance along the X
% axis
%
% * 'Set Row Noise Variance' slider control the noise variance along the Y
% axis
% 
% *Shot Noise-*
%
% * No distinct parameters
%
% 
%% Theoretical Background:
% 
% *Additive Gaussian Noise-*
% The source of Additive Gaussian Noise in digital images is the amplifier
% noise, caused primarily by Johnson–Nyquist noise (thermal noise),
% including that which comes from the reset noise of capacitors ("kTC
% noise").
% 
% Amplifier noise is a major part of the "read noise" of an image sensor,
% that is, of the constant noise level in dark areas of the image.
%
% Given a signal X, an Additive Gaussian noise model can be illustrated by:
%
% $$ \bar{I}(x,y) = I(x,y) + Z$$
%
% Where:
%
% $$  Z \sim \mathcal{N}  \left(  \mu, \sigma^2 \right) $$ 
%
% *Periodic Noise-*
% Periodic Noise can be generated by a variety of reasons, such as
% interference between electronic components, if the image signal is
% subjected to a periodic disturbance, moiré pattern caused by high
% resolution sampled by low resolution scanner\sensor, etc. 
% Example:
%
% Image with and without noise and their spectrum (FFT):
%
% <<Periodic_Noise_Image&Specturm.png>>
%
% Diff of the image spectrum:
%
% <<Periodic_Noise_Specturm_Diff.png>>
%
% As shown in the example, periodic and quasi-periodic noise results peaks
% in image spectrum amplitude. 
% Considering this, processing in the frequency domain may result in better
% solution than spatial domain operations (blurring for example, which can
% hide the periodic patterns at the cost of the edge sharpness reduction). 
%
% Periodic Noise model can be illustrated by:
%
% $$ \bar{I}(x,y) = I(x,y) + Z\cdot cos(x\cdot \omega_x + \theta_x) \cdot cos(y\cdot \omega_y + \theta_y)$$
%
% Where:
%
% $$  Z \sim \mathcal{N}  \left(  0, \sigma^2 \right) $$ 
%
% and $$\omega_x , \omega_y, \theta_x, \theta_y $$ are system dependent
% parameters.
%
% *Row - Column Noise-*
% Two independent noises are introduced: Row Noise and Column Noise.
%
% Column Fixed Pattern Noise (CFPN) mainly result from mismatches in column
% parallel architecture different components such as analog gain, ADCs, Reset- signal
% paths etc.  
% 
% Row Noise in CMOS sensors mainly caused by fluctuations in sensor array
% voltage, which cause fluctuations between rows in analog to digital
% conversions.
%
% Row - Column noise model can be illustrated by:
%
% $$ \bar{I}(x,y)  = I (x,y) + N_{row}(x,y) + N_{column}(x,y) $$
%
% Where:
%
% $$ N_{row}(x,y) = \left\{\begin{array}{ll}
% Z & x = 1\\ 
% N_{row}(x-1,y) & x>1 \\
% \end{array}\right.$$
%
% $$ N_{column}(x,y) = \left\{\begin{array}{ll}
% Z & y = 1\\ 
% N_{column}(x,y-1) & y>1 \\
% \end{array}\right.$$
%
% and 
%
% $$  Z \sim \mathcal{N}  \left(  \mu, \sigma \right) $$ 
%
% *Shot Noise-*
% Shot Noise typically caused by statistical quantum fluctuations, that is,
% variation in the number of photons sensed at a given exposure level. 
%
% Shot noise has a Poisson distribution, and the noises at different pixels are
% independent of one another. Due to the Poisson distribution nature of
% shot noise, the standard deviation of shot noise is equal to the square
% root of the average number of events N, therefore, the signal-to-noise
% ratio (SNR) is given by: 
% $SNR=\frac{N}{\sqrt{N}}=\sqrt{N}$.
%
% In addition to photon shot noise there can be additional shot noise from   
% the dark leakage current in the image sensor; this noise is otherwise
% known as "dark shot noise" or "dark-current shot noise". 
% 
% Shot Noise can be illustrated by:
% 
% $$ \bar{I}(x,y) = Pois(I(x,y)) $$
%
% i.e. for input pixel value of $I(x,y)$, the output is a random variable,
% Poisson distributed, with mean and variance of $\lambda = I(x,y)$.
%
% *Impulse Noise-*
% Also known as 'Salt-and-pepper noise' or 'spike noise'.
% It is characterized dark and bright pixels, regardless of the nature of
% the scene and it is caused by faulty pixels in the sensor array.
% Impulse Noise model can be illustrated by:
% 
% $$ \bar{I}(x,y) = \left\{\begin{array}{ll}
% I(x,y) & p/2<Z<p \\
% val_{min} &  Z<p/2 \\
% val_{max} & Z>p \\ 
% \end{array}\right.$$
%
% Where $Z$ is uniformly distributed variable in the range of [0,1]:
% 
% $$  Z \sim \mathcal{U}  \left[ 0,1 \right] $$ 
%
% $p$ is a system dependent parameter, at the range of [0,1],
%
% $val_{min}$ - minimum possible value (0).
%
% $val_{max}$ - maximum possible value ( 255 for uint8 images).
% 
% 
%% Reference:
% * Leslie Stroebel and Richard D. Zakia (1995). The Focal encyclopedia of photography. Focal Press. p. 507. ISBN 978-0-240-51417-8.
% * Jun Ohta (2008). Smart CMOS Image Sensors and Applications. CRC Press. ISBN 0-8493-3681-3.
% * Junichi Nakamura (2005). Image Sensors and Signal Processing for Digital Still Cameras. CRC Press. ISBN 0-8493-3545-0.
% * a b c Lindsay MacDonald (2006). Digital Heritage. Butterworth-Heinemann. ISBN 0-7506-6183-6.
% * Rafael C. Gonzalez, Richard E. Woods (2007). Digital Image Processing. Pearson Prenctice Hall. ISBN 0-13-168728-X.
% * Linda G. Shapiro and George C. Stockman (2001). Computer Vision. Prentice-Hall. ISBN 0-13-030796-3.
% * a b c Charles Boncelet (2005). "Image Noise Models". In Alan C. Bovik. Handbook of Image and Video Processing. Academic Press. ISBN 0-12-119792-1.
% * James R. Janesick (2001). Scientific Charge-coupled Devices. SPIE Press. ISBN 0-8194-3698-4.
% * a b Michael A. Covington (2007). Digital SLR Astrophotography. Cambridge University Press. ISBN 0-521-70081-7.
% * R. E. Jacobson, S. F. Ray, G. G. Attridge, and N. R. Axford (2000). The Manual of Photography. Focal Press. ISBN 0-240-51574-9.
% * Thomas S. Huang (1986). Advances in Computer Vision and Image Processing. JAI Press. ISBN 0-89232-460-0.
% * Brian W. Keelan and Robert E. Cookingham (2002). Handbook of Image Quality. CRC Press. ISBN 0-8247-0770-2.
% * Joseph G. Pellegrino et al. (2006). "Infrared Camera Characterization". In Joseph D. Bronzino. Biomedical Engineering Fundamentals. CRC Press. ISBN 0-8493-2122-0.
% * McHugh, Sean. "Digital Cameras: Does Pixel Size Matter? Part 2: Example Images using Different Pixel Sizes (Does Sensor Size Matter?)". Retrieved 2010-06-03.
% * R. N., Clark (2008-12-22). "Digital Cameras: Does Pixel Size Matter? Part 2: Example Images using Different Pixel Sizes (Does Sensor Size Matter?)". Retrieved 2010-06-03.
% * Wrotniak, J. Anderzej (2009-02-26). "Four Thirds Sensor Size and Aspect Ratio". Retrieved 2010-06-03.
% * Aizenberg, Igor N.; Butakoff, Constantine; (2002). "Frequency domain medianlike filter for periodic and quasi-periodic
% noise removal".


function NoiseModels = NoiseModels_mb( handles )

    handles = guidata(handles.figure1);
    k=1;
    axes_hor = 2;
    axes_ver = 2;
    is_outerposition = zeros(1, axes_hor*axes_ver);
    is_outerposition(3:4) = 1;

    button_pos = get(handles.pushbutton12, 'position');
    bottom =button_pos(2);
    left = button_pos(1)+button_pos(3);
        NoiseModels = DeployAxes( handles.figure1, ...
            [axes_hor, ...
            axes_ver], ...
            bottom, ...
            left, ...
            0.9, ...
            0.9, ...
            is_outerposition);
% initial params
    NoiseModels.im = HandleFileList('load' , HandleFileList('get' , handles.image_index));
    NoiseModels.noise_mean =0;
    NoiseModels.noise_std =0.01;    
    NoiseModels.thr = 0.01;  
    NoiseModels.omega_x= []; 
    NoiseModels.omega_y = [];
    NoiseModels.theta_x =[];
    NoiseModels.theta_y=[]; 
    NoiseModels.noise_type = 'Additive Gaussian Noise';
%
	k=1;
	interface_params(k).style = 'pushbutton';
	interface_params(k).title = 'Run Experiment';
	interface_params(k).callback = @(a,b)run_process_image(a);
    
	k=k+1;
	interface_params =  SetSliderParams('Set Gaussian additive noise StDev', 128, 0, NoiseModels.noise_std, 1, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
    
    k=k+1;
	interface_params =  SetSliderParams('Set Threshold For Noise Detection', 2, 0, NoiseModels.thr, 1/1000, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'thr',@update_sliders), interface_params, k);
    
    k=k+1;    
    interface_params(k).style = 'buttongroup';
    interface_params(k).title = 'Choose Noise Type';
    interface_params(k).selection ={ 'Additive Gaussian Noise', 'Periodic Noise' , 'Row - Column Noise', 'Shot Noise', 'Impulse Noise'};   
    interface_params(k).callback = @(a,b)ChooseNoiseType(a,b,handles);  
    
    
    
    
    
    
    
    
    
    

    NoiseModels.buttongroup_handle = SetInteractiveInterface(handles, interface_params); 
         


%
    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std,    NoiseModels.thr, ...
    NoiseModels.omega_x, NoiseModels.omega_y, NoiseModels.theta_x, NoiseModels.theta_y, ...
    NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);

 end


function update_sliders(handles)
	if ( ~isstruct(handles))
		handles = guidata(handles);
	end
	if ( strcmpi(handles.interactive, 'on'))
		run_process_image(handles);
	end
	guidata(handles.figure1,handles );
end

function run_process_image(handles)
    if ( ~isstruct(handles))
        handles = guidata(handles);
    end



NoiseModels = handles.(handles.current_experiment_name);

    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std,    NoiseModels.thr, ...
    NoiseModels.omega_x, NoiseModels.omega_y, NoiseModels.theta_x, NoiseModels.theta_y, ...
    NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);
end

function ChooseNoiseType(a,b,handles)
    handles = guidata(handles.figure1);
    handles.(handles.current_experiment_name).noise_type = get(b.NewValue, 'string');
    NoiseModels  = handles.(handles.current_experiment_name);
    delete(NoiseModels.buttongroup_handle);

    %%
	k=1;
	interface_params(k).style = 'pushbutton';
	interface_params(k).title = 'Run Experiment';
	interface_params(k).callback = @(a,b)run_process_image(a);
	k=k+1;
    NoiseModels.thr = 0.01;
    switch NoiseModels.noise_type
        case  'Additive Gaussian Noise'
            val = 1;
            NoiseModels.noise_mean =0;
            NoiseModels.noise_std =0.01;    
            NoiseModels.omega_x= []; 
            NoiseModels.omega_y = [];
            NoiseModels.theta_x =[];
            NoiseModels.theta_y=[]; 
            interface_params =  SetSliderParams('Additive Gaussian StDev', 0.1, 0, NoiseModels.noise_std, 1/1000, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;

        case 'Periodic Noise' 
            val = 2;
            NoiseModels.noise_std =20;    
            NoiseModels.omega_x= 0.5; 
            NoiseModels.omega_y = 0.5;
            NoiseModels.theta_x =0;
            NoiseModels.theta_y=0; 
            NoiseModels.noise_mean =[];
            interface_params =  SetSliderParams('Set Noise StDev', 50, 0, NoiseModels.noise_std, 1/100, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('Set Omega X', pi, 0, NoiseModels.omega_x, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'omega_x',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('Set Omega Y', pi, 0, NoiseModels.omega_y, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'omega_y',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('Set Theta X', pi, 0, NoiseModels.theta_x, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'theta_x',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('Set Theta Y', pi, 0, NoiseModels.theta_y, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'theta_y',@update_sliders), interface_params, k);
            k=k+1;
        case  'Row - Column Noise'
            NoiseModels.omega_x= 0.1; 
            NoiseModels.omega_y = 0.1;
            NoiseModels.theta_x =[];
            NoiseModels.theta_y=[]; 
            NoiseModels.noise_mean =[];
            NoiseModels.noise_std =[]; 
            val = 3;
            
            interface_params =  SetSliderParams('Set column noise StDev', 255, 0, NoiseModels.omega_x, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'omega_x',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('Set row noise StDev', 255, 0, NoiseModels.omega_y, 1/100, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'omega_y',@update_sliders), interface_params, k);
            k=k+1;
        case 'Shot Noise' 
            NoiseModels.omega_x= []; 
            NoiseModels.omega_y = [];
            NoiseModels.theta_x =[];
            NoiseModels.theta_y=[]; 
            val = 4;
        case 'Impulse Noise'
            NoiseModels.omega_x= []; 
            NoiseModels.omega_y = [];
            NoiseModels.theta_x =[];
            NoiseModels.theta_y=[]; 
            val = 5;
            NoiseModels.noise_std = 0.1;
            interface_params =  SetSliderParams('Set Probability of impulse', 1, 0, NoiseModels.noise_std , 1/100, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;
    end
    interface_params =  SetSliderParams('Set Threshold For Noise Detection', 2, 0, NoiseModels.thr, 1/1000, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'thr',@update_sliders), interface_params, k);
    k=k+1;


    interface_params(k).style = 'buttongroup';
    interface_params(k).title = 'Choose Noise Type';
    interface_params(k).selection ={ 'Additive Gaussian Noise', 'Periodic Noise' , 'Row - Column Noise', 'Shot Noise', 'Impulse Noise'};   
    interface_params(k).value = val;
    interface_params(k).callback = @(a,b)ChooseNoiseType(a,b,handles);  



    
    
    
    
    
    
    
    
    


    NoiseModels.buttongroup_handle = SetInteractiveInterface(handles, interface_params); 
         

    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std,    NoiseModels.thr, ...
    NoiseModels.omega_x, NoiseModels.omega_y, NoiseModels.theta_x, NoiseModels.theta_y, ...
    NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);
    
    handles.(handles.current_experiment_name) = NoiseModels;
    
    guidata(    handles.figure1, handles);
end

function process_image(im, noise_type, noise_mean, noise_std,   thr, ...
    omega_x, omega_y, theta_x, theta_y, ...
    axes_1, axes_2, axes_3, axes_4)
     %
     
    delete(get(axes_1, 'children'));
    delete(get(axes_2, 'children'));
    delete(get(axes_3, 'children'));
    delete(get(axes_4, 'children'));
    imshow(im, [0 255],  'parent', axes_1); 
    DisplayAxesTitle( axes_1, ['Test Image'], 'TM');  

     %
    switch noise_type 
        case  'Additive Gaussian Noise'
            im_w_noise = im + noise_mean + noise_std*randn(size(im));      
            imshow(im_w_noise, [0 255],  'parent', axes_2); 
            DisplayAxesTitle( axes_2, ['Image with Gaussian noise, \theta = ' num2str(noise_mean) ' \sigma =' num2str(noise_std)], 'TM');  
        case 'Periodic Noise' 
            [x, y] = meshgrid(1:size(im,2), 1:size(im,1));
            noise = rand(size(im)) .*cos(omega_x*x + theta_x) .*cos(omega_y*y + theta_y);

            noise = noise_std *(noise-mean(noise(:)))/std(noise(:),1) ;
            im_w_noise = im + noise;
            imshow(im_w_noise, [0 255],  'parent', axes_2); 
            DisplayAxesTitle( axes_2, {['Image with Periodic noise'],['\omega_x=' num2str(omega_x) ', \theta_x = ' num2str(theta_x)  '  \omega_y=' num2str(omega_y) ', \theta_y = ' num2str(theta_y)]}, 'TM'); 
        case 'Row - Column Noise'
            row_noise = omega_y*randn(size(im,1), 1)*ones(1,size(im,2));
            column_noise = omega_x*ones(size(im,1),1)*randn(1, size(im,2));
            noise = row_noise+column_noise;
            im_w_noise = im + noise;
            imshow(im_w_noise, [0 255],  'parent', axes_2); 
            DisplayAxesTitle( axes_2, {['Image with Row - Column Noise'],['\sigma_x=' num2str(omega_x) ', \sigma_y =' num2str(omega_y) ]}, 'TM'); 

        case 'Shot Noise'
            im_w_noise = uint8(imnoise(uint8(im), 'poisson'));
            imshow(im_w_noise, [0 255],  'parent', axes_2); 
            DisplayAxesTitle( axes_2, 'Image with Shot noise, (Poisson distribution)', 'TM');  

        case 'Impulse Noise'
            [SzX SzY]=size(im);
            noisemask=rand(SzX,SzY)<noise_std;
            im_w_noise=(ones(SzX,SzY)-noisemask).*im+256*rand(SzX,SzY).*noisemask;
            imshow(im_w_noise, [0 255],  'parent', axes_2); 
            DisplayAxesTitle( axes_2, ['Image with impulse noise, P = ' num2str(noise_std)], 'TM');  
    end
    [SzX SzY]=size(im_w_noise);
    sp=fft(im_w_noise');
    sp2=abs(sp).^2;
    sp1d_im_w_noise=(sum(sp2'));
    sp1d_im_w_noise = sp1d_im_w_noise(1:round(SzX/2) + 1);
    sp1dsm=monotone_mb(sp1d_im_w_noise,thr);
    sp1d_noise=sp1d_im_w_noise-sp1dsm;
    
    sp=fft(im');
    sp2=abs(sp).^2;
    sp1d_im=(sum(sp2'));
    sp1d_im =sp1d_im(1:round(SzX/2) + 1);
    plot( sp1d_im.^0.3, 'parent', axes_3, 'color', 'g', 'LineStyle', '-', 'Marker', '*', 'linewidth', 2); hold(axes_3, 'on');
    plot( sp1d_im_w_noise.^0.3, 'parent', axes_3, 'color', 'r', 'LineStyle', '-', 'Marker', '.', 'linewidth', 2); hold(axes_3, 'on');
    plot( sp1d_noise.^0.3, 'parent', axes_3, 'color', 'b', 'LineStyle', '-', 'Marker', '+', 'linewidth', 2);
    set(axes_3, 'XLim', [1 50]);
    h_l = legend(axes_3, 'Test Image Spectrum', 'Noisy Image Spectrum', 'Noise Only Spectrum');
    set(h_l, 'fontsize', 8);
    grid(axes_3, 'on');
    DisplayAxesTitle( axes_3, ['Power spectrum'], 'BM');  
    
    

%OUTIMG=sp1d(1:SzX/2+1)-sp1dsm;

   % noise spectrum
    
    [OUT cor_im]=noisevar_mb(im);
    [OUT cor_im_w_noise]=noisevar_mb(im_w_noise);
    plot([-128 : 127],fftshift(cor_im), 'parent', axes_4, 'color' , 'b','linewidth', 2); hold(axes_4, 'on');
    grid(axes_4, 'on');
    plot([-128 : 127],fftshift(cor_im_w_noise), 'parent', axes_4, 'color', 'g', 'linewidth', 2); hold(axes_4, 'on');
    h_l = legend(axes_4, 'Test Image Correlation', 'Noisy Image Correlation');
    set(h_l, 'fontsize', 8);
    DisplayAxesTitle( axes_4, ['Auto-correlation function'], 'BM');

end