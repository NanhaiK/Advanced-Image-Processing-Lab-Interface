%% Noise Model
%  Illustration of different noise types in digital images.
%% Experiment Description:
% This experiment illustrates the different noises effect digital image
% capturing, and the noise effect on the 1D power spectrum and auto
% correlation function of the image.
%
% a method of detecting the noise from the power spectrum is also
% introduced, and its sensitivity is controllable.
% 
% The noises introduced are:
%
% * Additive Gaussian Noise
% * Periodic Noise
% * Banding noise
% * Shot Noise
% * Impulse Noise
%% Tasks: 
% 6.1.1. Additive noise model.
%
% Generate and observe additive Gaussian noise in images. Compare 1-D power spectra
% of noisy and noise less images. Observe image auto-correlation functions (program
% corimg1d.m). Evaluate noise variance (program noisevar.m) and investigate its accuracy for
% different SNR.
% Generate Moire noise image, use program detmoir1.m to characterize it. Images
% moire.img, jeep.img, magcrop.img can be used along with those generated by you.
%
% 6.1.2. Impulse noise model.
%
% Generate and observe impulse noise in images. Observe difference signal histograms
% of noisy and noise less images (program pnoise.m). Investigate, how noise variance
% estimation found by program noisevar.m is connected to the probability of errors.
%
%% Instruction:
% use the 'Choose noise Type' panel to switch between the different noise
% models presented.
%
% Each of the noise mode has distinct parameters which effect behavior of
% the noise.
%
% For all noises models the noise detection parameter can be controlled by
% the 'Set Threshold For noise Detection' slider.
%
% *Additive Gaussian noise -*
% 
% * 'Set Gaussian STD' sliders control the mean and
% variance of the Gaussian noise added to the image.
%
% *Periodic Noise-*
%
% * 'Set Omega X',  'Set Theta X' sliders control the frequency and phase of
% the Additive Moire noise along the X axis.
%
% * 'Set Omega Y',  'Set Theta Y' sliders control the frequency and phase of
% the Additive Moire noise along the Y axis.
% 
% * 'Set noise Variance' slider controls the overall noise variance (along X
% and Y axis). 
%
% *Banding noise-* 
% 
% * 'Set Column noise Variance' slider control the noise variance along the X
% axis
%
% * 'Set Row noise Variance' slider control the noise variance along the Y
% axis
% 
% *Shot Noise-*
%
% * No distinct parameters
%
% 
%% Theoretical Background:
% 
% *Additive Gaussian Noise-*
% The source of Additive Gaussian noise in digital images is the amplifier
% noise, caused primarily by Johnson–Nyquist noise (thermal noise),
% including that which comes from the reset noise of capacitors ("kTC
% noise").
% 
% Amplifier noise is a major part of the "read noise" of an image sensor,
% that is, of the constant noise level in dark areas of the image.
%
% Given a signal X, an Additive Gaussian noise model can be illustrated by:
%
% $$ \bar{I}(x,y) = I(x,y) + Z$$
%
% Where:
%
% $$  Z \sim \mathcal{N}  \left(  \mu, \sigma^2 \right) $$ 
%
% *Periodic Noise-*
% Moire noise can be generated by a variety of reasons, such as
% interference between electronic components, if the image signal is
% subjected to a Moire disturbance, moiré pattern caused by high
% resolution sampled by low resolution scanner\sensor, etc. 
% Example:
%
% Image with and without noise and their spectrum (FFT):
%
% <<Periodic_Noise_Image&Specturm.png>>
%
% Diff of the image spectrum:
%
% <<Periodic_Noise_Specturm_Diff.png>>
%
% As shown in the example, Moire and quasi-Moire noise results peaks
% in image spectrum amplitude. 
% Considering this, processing in the frequency domain may result in better
% solution than spatial domain operations (blurring for example, which can
% hide the Moire patterns at the cost of the edge sharpness reduction). 
%
% Moire noise model can be illustrated by:
%
% $$ \bar{I}(x,y) = I(x,y) + Z\cdot cos(x\cdot \omega_x + \theta_x) \cdot cos(y\cdot \omega_y + \theta_y)$$
%
% Where:
%
% $$  Z \sim \mathcal{N}  \left(  0, \sigma^2 \right) $$ 
%
% and $$\omega_x , \omega_y, \theta_x, \theta_y $$ are system dependent
% parameters.
%
% *Banding noise-*
% Two independent noises are introduced: Row noise and Column Noise.
%
% Column Fixed Pattern noise (CFPN) mainly result from mismatches in column
% parallel architecture different components such as analog gain, ADCs, Reset- signal
% paths etc.  
% 
% Row noise in CMOS sensors mainly caused by fluctuations in sensor array
% voltage, which cause fluctuations between rows in analog to digital
% conversions.
%
% Banding noise model can be illustrated by:
%
% $$ \bar{I}(x,y)  = I (x,y) + N_{row}(x,y) + N_{column}(x,y) $$
%
% Where:
%
% $$ N_{row}(x,y) = \left\{\begin{array}{ll}
% Z & x = 1\\ 
% N_{row}(x-1,y) & x>1 \\
% \end{array}\right.$$
%
% $$ N_{column}(x,y) = \left\{\begin{array}{ll}
% Z & y = 1\\ 
% N_{column}(x,y-1) & y>1 \\
% \end{array}\right.$$
%
% and 
%
% $$  Z \sim \mathcal{N}  \left(  \mu, \sigma \right) $$ 
%
% *Shot Noise-*
% Shot noise typically caused by statistical quantum fluctuations, that is,
% variation in the number of photons sensed at a given exposure level. 
%
% Shot noise has a Poisson distribution, and the noises at different pixels are
% independent of one another. Due to the Poisson distribution nature of
% shot noise, the standard deviation of shot noise is equal to the square
% root of the average number of events N, therefore, the signal-to-noise
% ratio (SNR) is given by: 
% $SNR=\frac{N}{\sqrt{N}}=\sqrt{N}$.
%
% In addition to photon shot noise there can be additional shot noise from   
% the dark leakage current in the image sensor; this noise is otherwise
% known as "dark shot noise" or "dark-current shot noise". 
% 
% Shot noise can be illustrated by:
% 
% $$ \bar{I}(x,y) = Pois(I(x,y)) $$
%
% i.e. for input pixel value of $I(x,y)$, the output is a random variable,
% Poisson distributed, with mean and variance of $\lambda = I(x,y)$.
%
% *Impulse Noise-*
% Also known as 'Salt-and-pepper noise' or 'spike noise'.
% It is characterized dark and bright pixels, regardless of the nature of
% the scene and it is caused by faulty pixels in the sensor array.
% Impulse noise model can be illustrated by:
% 
% $$ \bar{I}(x,y) = \left\{\begin{array}{ll}
% I(x,y) & p/2<Z<p \\
% val_{min} &  Z<p/2 \\
% val_{max} & Z>p \\ 
% \end{array}\right.$$
%
% Where $Z$ is uniformly distributed variable in the range of [0,1]:
% 
% $$  Z \sim \mathcal{U}  \left[ 0,1 \right] $$ 
%
% $p$ is a system dependent parameter, at the range of [0,1],
%
% $val_{min}$ - minimum possible value (0).
%
% $val_{max}$ - maximum possible value ( 255 for uint8 images).
% 
% 
%% Reference:
% * Leslie Stroebel and Richard D. Zakia (1995). The Focal encyclopedia of photography. Focal Press. p. 507. ISBN 978-0-240-51417-8.
% * Jun Ohta (2008). Smart CMOS Image Sensors and Applications. CRC Press. ISBN 0-8493-3681-3.
% * Junichi Nakamura (2005). Image Sensors and Signal Processing for Digital Still Cameras. CRC Press. ISBN 0-8493-3545-0.
% * a b c Lindsay MacDonald (2006). Digital Heritage. Butterworth-Heinemann. ISBN 0-7506-6183-6.
% * Rafael C. Gonzalez, Richard E. Woods (2007). Digital Image Processing. Pearson Prenctice Hall. ISBN 0-13-168728-X.
% * Linda G. Shapiro and George C. Stockman (2001). Computer Vision. Prentice-Hall. ISBN 0-13-030796-3.
% * a b c Charles Boncelet (2005). "Image noise Models". In Alan C. Bovik. Handbook of Image and Video Processing. Academic Press. ISBN 0-12-119792-1.
% * James R. Janesick (2001). Scientific Charge-coupled Devices. SPIE Press. ISBN 0-8194-3698-4.
% * a b Michael A. Covington (2007). Digital SLR Astrophotography. Cambridge University Press. ISBN 0-521-70081-7.
% * R. E. Jacobson, S. F. Ray, G. G. Attridge, and N. R. Axford (2000). The Manual of Photography. Focal Press. ISBN 0-240-51574-9.
% * Thomas S. Huang (1986). Advances in Computer Vision and Image Processing. JAI Press. ISBN 0-89232-460-0.
% * Brian W. Keelan and Robert E. Cookingham (2002). Handbook of Image Quality. CRC Press. ISBN 0-8247-0770-2.
% * Joseph G. Pellegrino et al. (2006). "Infrared Camera Characterization". In Joseph D. Bronzino. Biomedical Engineering Fundamentals. CRC Press. ISBN 0-8493-2122-0.
% * McHugh, Sean. "Digital Cameras: Does Pixel Size Matter? Part 2: Example Images using Different Pixel Sizes (Does Sensor Size Matter?)". Retrieved 2010-06-03.
% * R. N., Clark (2008-12-22). "Digital Cameras: Does Pixel Size Matter? Part 2: Example Images using Different Pixel Sizes (Does Sensor Size Matter?)". Retrieved 2010-06-03.
% * Wrotniak, J. Anderzej (2009-02-26). "Four Thirds Sensor Size and Aspect Ratio". Retrieved 2010-06-03.
% * Aizenberg, Igor N.; Butakoff, Constantine; (2002). "Frequency domain medianlike filter for periodic and quasi-periodic
% noise removal".


function NoiseModels = NoiseModels_mb( handles )

    handles = guidata(handles.figure1);
    k=1;
    axes_hor = 2;
    axes_ver = 2;
    button_pos = get(handles.pushbutton12, 'position');
    bottom =button_pos(2);
    left = button_pos(1)+button_pos(3);
        NoiseModels = DeployAxes( handles.figure1, ...
            [axes_hor, ...
            axes_ver], ...
            bottom, ...
            left, ...
            0.9, ...
            0.9);
% initial params
    NoiseModels.im = HandleFileList('load' , HandleFileList('get' , handles.image_index));
    NoiseModels.noise_mean =0;
    NoiseModels.noise_std =0;
    NoiseModels.NumOfComp = [];
    NoiseModels.noise_type = 'Additive Gaussian noise';
%
	k=1;
	interface_params(k).style = 'pushbutton';
	interface_params(k).title = 'Run Experiment';
	interface_params(k).callback = @(a,b)run_process_image(a);
    
	k=k+1;
	interface_params =  SetSliderParams('Set Gaussian additive noise StDev', 50, 0, NoiseModels.noise_std, 1, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);

    k=k+1;    
    interface_params(k).style = 'buttongroup';
    interface_params(k).title = 'Choose noise Type';
    interface_params(k).selection ={ 'Impulse noise', 'Shot noise', 'Banding noise', 'Moire noise', 'Additive Gaussian noise'};   
    interface_params(k).value = find(strcmpi(interface_params(k).selection, NoiseModels.noise_type));
    interface_params(k).callback = @(a,b)ChooseNoiseType(a,b,handles);

    NoiseModels.buttongroup_handle = SetInteractiveInterface(handles, interface_params); 
         
    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std, NoiseModels.NumOfComp, ...
        NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);

 end


function update_sliders(handles)
	if ( ~isstruct(handles))
		handles = guidata(handles);
	end
	if ( strcmpi(handles.interactive, 'on'))
		run_process_image(handles);
	end
	guidata(handles.figure1,handles );
end

function run_process_image(handles)
    if ( ~isstruct(handles))
        handles = guidata(handles);
    end
    NoiseModels = handles.(handles.current_experiment_name);
    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std, NoiseModels.NumOfComp, ...
        NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);
end

function ChooseNoiseType(a,b,handles)
    handles = guidata(handles.figure1);
    handles.(handles.current_experiment_name).noise_type = get(b.NewValue, 'string');
    NoiseModels  = handles.(handles.current_experiment_name);
    delete(NoiseModels.buttongroup_handle);
    NoiseModels = rmfield(NoiseModels, 'buttongroup_handle');
    %
	k=1;
	interface_params(k).style = 'pushbutton';
	interface_params(k).title = 'Run Experiment';
	interface_params(k).callback = @(a,b)run_process_image(a);
	k=k+1;
    switch NoiseModels.noise_type
        case  'Additive Gaussian noise'
            NoiseModels.noise_mean =0;
            NoiseModels.noise_std =0.01;    
            interface_params =  SetSliderParams('Set Gaussian additive noise StDev', 50, 0, NoiseModels.noise_std, 1, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;
        case 'Moire noise' 
            NoiseModels.noise_std =180;    
            NoiseModels.NumOfComp= 15; 
            NoiseModels.noise_mean =[];
            interface_params =  SetSliderParams('Noise intensity', 255, 0, NoiseModels.noise_std, 1/10, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;
            interface_params =  SetSliderParams('number of noise spectral components', 128, 1, NoiseModels.NumOfComp, 1, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'NumOfComp',@update_sliders), interface_params, k);
            k=k+1;
        case  'Banding noise'
            NoiseModels.noise_std =128; 
            interface_params =  SetSliderParams('Set The banding noise range', 255, 0, NoiseModels.noise_std, 1, @(a,b)SetParam(a, b, k, handles.current_experiment_name,'noise_std',@update_sliders), interface_params, k);
            k=k+1;
        case 'Shot noise' 

        case 'Impulse noise'
 
            NoiseModels.noise_std = 0.1;
            interface_params =  SetSliderParams('Set Probability of error', 0.5, 0, NoiseModels.noise_std , 1/100, @(a,b)SetParam(a,b,k,handles.current_experiment_name, 'noise_std',@update_sliders), interface_params, k);
            k=k+1;
    end
    interface_params(k).style = 'buttongroup';
    interface_params(k).title = 'Choose noise Type';
    interface_params(k).selection ={ 'Impulse noise', 'Shot noise', 'Banding noise', 'Moire noise', 'Additive Gaussian noise'};   
    interface_params(k).value = find(strcmpi(interface_params(k).selection, NoiseModels.noise_type));
    interface_params(k).callback = @(a,b)ChooseNoiseType(a,b,handles);  
    NoiseModels.buttongroup_handle = SetInteractiveInterface(handles, interface_params); 
    process_image(NoiseModels.im,NoiseModels.noise_type, NoiseModels.noise_mean, NoiseModels.noise_std, NoiseModels.NumOfComp, ...
        NoiseModels.axes_1, NoiseModels.axes_2, NoiseModels.axes_3, NoiseModels.axes_4);
    handles.(handles.current_experiment_name) = NoiseModels;
    guidata(    handles.figure1, handles);
end

function process_image(im, noise_type, noise_mean, noise_std,NumOfComp,...
    axes_1, axes_2, axes_3, axes_4)
     %
     
    delete(get(axes_1, 'children'));
    delete(get(axes_2, 'children'));
    delete(get(axes_3, 'children'));
    delete(get(axes_4, 'children'));
    imshow(im, [0 255],  'parent', axes_1); 
    DisplayAxesTitle( axes_1, ['Test image'], 'TM',10);  

    [SzY, SzX] = size(im);
    switch noise_type 
        case  'Additive Gaussian noise'
            im_w_noise = im + noise_mean + noise_std*randn(size(im));
            imshow(im_w_noise, [0 255],  'parent', axes_2);
            DisplayAxesTitle( axes_2, ['Image with Gaussian noise, \theta = ' num2str(noise_mean) ' \sigma =' num2str(noise_std)], 'TM',10);  
        case 'Moire noise' 
%             [x, y] = meshgrid(1:size(im,2), 1:size(im,1));
%             noise = rand(size(im)) .*cos(omega_x*x + theta_x) .*cos(omega_y*y + theta_y);
%             noise = noise_std *(noise-mean(noise(:)))/std(noise(:),1) ;

            noise=dct2((rand(SzX,SzY)<NumOfComp/(SzX*SzY)).*(rand(SzX,SzY)-0.5)); 
            noise(1,1)=0;
            if ( max(abs(noise(:))) ~= 0 )
                noise=noise_std*noise/max(abs(noise(:)));
            end
            im_w_noise = im + noise;
            imshow(im_w_noise, [0 255],  'parent', axes_2);
%             DisplayAxesTitle( axes_2, {['Image with Moire noise'],['\omega_x=' num2str(omega_x) ', \theta_x = ' num2str(theta_x)  '  \omega_y=' num2str(omega_y) ', \theta_y = ' num2str(theta_y)]}, 'TM',10); 
            DisplayAxesTitle( axes_2, {['Image with moire noise'],['number of noise spectral components=' num2str(NumOfComp) ', Noise intensity = ' num2str(noise_std)]}, 'TM',10); 
        case 'Banding noise'
%             row_noise = omega_y*randn(size(im,1), 1)*ones(1,size(im,2));
%             column_noise = omega_x*ones(size(im,1),1)*randn(1, size(im,2));
%             noise = row_noise+column_noise;
            noise=kron(noise_std*(rand(SzX,1)-0.5),ones(1,SzY));
            im_w_noise = im + noise;
            im_w_noise(im_w_noise<0) = 0;
            im_w_noise(im_w_noise>255) = 255;
            imshow(im_w_noise, [0 255],  'parent', axes_2);
%             DisplayAxesTitle( axes_2, {['Image with banding noise'],['\sigma_x=' num2str(omega_x) ', \sigma_y =' num2str(omega_y) ]}, 'TM',10); 
            DisplayAxesTitle( axes_2, {['Image with banding noise'],['noise range=' num2str(noise_std) ]}, 'TM',10); 
        case 'Shot noise'
            im_w_noise = uint8(imnoise(uint8(im), 'poisson'));
            imshow(im_w_noise, [0 255],  'parent', axes_2);
            DisplayAxesTitle( axes_2, 'Image with shot noise, (Poisson distribution)', 'TM',10);  

        case 'Impulse noise'
            noisemask=rand(SzX,SzY)<noise_std;
            im_w_noise=(1-noisemask).*im+255*rand(SzX,SzY).*noisemask;
            imshow(im_w_noise, [0 255],  'parent', axes_2);
            DisplayAxesTitle( axes_2, ['Image with impulse noise, Perror = ' num2str(noise_std)], 'TM',10);  
    end
    
    sp=fft(im_w_noise');
    sp2=abs(sp).^2;
    sp1d_im_w_noise=(sum(sp2'));
    sp1d_im_w_noise = sp1d_im_w_noise(1:round(SzX/2) + 1);

%     sp1dsm=monotone_mb(sp1d_im_w_noise,thr);

    sp=fft(im');
    sp2=abs(sp).^2;
    sp1d_im=(sum(sp2'));
    sp1d_im =sp1d_im(1:round(SzX/2) + 1);
    
    sp1d_noise = abs(sp1d_im - sp1d_im_w_noise);
    plot( sp1d_im.^0.3, 'parent', axes_3, 'color', 'g', 'LineStyle', '-', 'Marker', '*', 'linewidth', 2); hold(axes_3, 'on');
    plot( sp1d_im_w_noise.^0.3, 'parent', axes_3, 'color', 'r', 'LineStyle', '-', 'Marker', '.', 'linewidth', 2); hold(axes_3, 'on');
    plot( sp1d_noise.^0.3, 'parent', axes_3, 'color', 'b', 'LineStyle', '-', 'Marker', '+', 'linewidth', 2);
    set(axes_3, 'XLim', [1 50]);
    h_l = legend(axes_3, 'Test image spectrum', 'Noisy image spectrum', 'noise spectrum');
    set(h_l, 'fontsize', 8);
    grid(axes_3, 'on');
    DisplayAxesTitle( axes_3, ['Power spectrum'], 'BM',10);  
   
    [OUT cor_im]=noisevar_mb(im);
    [OUT cor_im_w_noise]=noisevar_mb(im_w_noise);
    plot([-128 : 127],fftshift(cor_im), 'parent', axes_4, 'color' , 'b','linewidth', 2); hold(axes_4, 'on');
    grid(axes_4, 'on');
    plot([-128 : 127],fftshift(cor_im_w_noise), ':r', 'parent', axes_4,  'linewidth', 2); hold(axes_4, 'on');
    axis(axes_4, 'tight');
    h_l = legend(axes_4, 'Test Image Correlation', 'Noisy Image Correlation');
    set(h_l, 'fontsize', 8);
    DisplayAxesTitle( axes_4, ['Auto-correlation function'], 'BM',10);

end